# -*- coding: utf-8 -*-
"""SE_proj.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1VqvT7I0yt4D6OnVBaBEKc7q1up8ilxRG

# **Sprint 1 (Car Sales Data)**
"""

import numpy as np
import pandas as pd
import tensorflow as tf
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler

# Load the data
data = pd.read_csv("Historical_Data.csv")  # Replace "your_file.csv" with the name of your CSV file

# Drop non-numeric columns
X = data.drop(columns=["Sold_Units", "Country_Code"])  # Features
y = data["Sold_Units"]  # Target

# Split the data into training and testing sets
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Standardize the features
scaler = StandardScaler()
X_train_scaled = scaler.fit_transform(X_train)
X_test_scaled = scaler.transform(X_test)

# Define the neural network model
model = tf.keras.Sequential([
    tf.keras.layers.Dense(64, activation='relu', input_shape=(X_train_scaled.shape[1],)),
    tf.keras.layers.Dense(32, activation='relu'),
    tf.keras.layers.Dense(1)  # Output layer
])

# Compile the model
model.compile(optimizer='adam', loss='mean_squared_error')

# Train the model
history = model.fit(X_train_scaled, y_train, epochs=50, batch_size=32, validation_split=0.2)

# Evaluate the model
loss = model.evaluate(X_test_scaled, y_test)
print("Test Loss:", loss)

# Predict sales
predictions = model.predict(X_test_scaled)

import numpy as np

# Generate features for the next 10 days (assuming X_train contains historical data)
# For demonstration purposes, let's assume the features are randomly generated
num_days = 10
num_features = X_train.shape[1]  # Number of features in the dataset
next_10_days_features = np.random.rand(num_days, num_features)

# Preprocess the features
next_10_days_features_scaled = scaler.transform(next_10_days_features)

# Make predictions for the next 10 days
next_10_days_predictions = model.predict(next_10_days_features_scaled)

# Print the predictions
print("Predictions for the next 10 days:")
print(next_10_days_predictions)

"""# **Generating Ice Cream Sales Data (Sprint 2)**

# **AI Model For Prediction**
"""

import pandas as pd
from datetime import datetime, timedelta
from sklearn.preprocessing import OneHotEncoder
from sklearn.compose import ColumnTransformer
from sklearn.pipeline import Pipeline
from sklearn.linear_model import LinearRegression

# Function to load data
def load_data(file_path):
    data = pd.read_excel(file_path)
    data['Date'] = pd.to_datetime(data['Date'])
    data['Day of Week'] = data['Date'].dt.dayofweek
    data['Month'] = data['Date'].dt.month
    return data.drop(columns=['Date'])

# Function to prepare the model
def prepare_model(data):
    X = data.drop(columns=["Revenue ($)"])
    y = data["Revenue ($)"]
    categorical_columns = X.select_dtypes(include=['object']).columns.tolist()
    categorical_columns += ['Day of Week', 'Month']
    preprocessor = ColumnTransformer(
        transformers=[
            ('cat', OneHotEncoder(handle_unknown='ignore'), categorical_columns)
        ],
        remainder='passthrough'
    )
    model = Pipeline(steps=[
        ('preprocessor', preprocessor),
        ('regressor', LinearRegression())
    ])
    return model, X, y

# Function to train the model
def train_model(model, X, y):
    model.fit(X, y)
    return model

# Function to make predictions
def make_predictions(model, new_data):
    return model.predict(new_data)

# Function to generate data for multiple days
def generate_data_for_days(start_date, num_days):
    base_date = pd.to_datetime(start_date)
    dates = [base_date + timedelta(days=i) for i in range(num_days)]
    days_of_week = [date.dayofweek for date in dates]
    months = [date.month for date in dates]
    new_data = pd.DataFrame({
        'Day of Week': days_of_week,
        'Month': months,
        'Flavor': ['Vanilla'] * num_days,
        'Cup Size': ['Medium'] * num_days,
        'Units Sold': [30] * num_days,
        'Promotions': ['20% off'] * num_days,
        'Seasonality': ['Winter'] * num_days,
        'Distribution Channel': ['Supermarket'] * num_days,
        'Economic Indicators': ['Growing'] * num_days,
        'Competitor Activity': ['Competitor price drop'] * num_days,
        'Inventory Levels': ['Low'] * num_days,
        'Social Media Engagement (%)': [5] * num_days,
        'Ingredient Price Increase (%)': [2] * num_days
    })
    return new_data

# Function to save predictions to a CSV file
def save_predictions_to_csv(predictions, start_date, num_days):
    dates = [pd.to_datetime(start_date) + timedelta(days=i) for i in range(num_days)]
    df = pd.DataFrame({
        'Date': dates,
        'Predicted Revenue ($)': predictions
    })
    csv_file_path = f"Predictions_from_{start_date}_for_{num_days}_days.csv"
    df.to_csv(csv_file_path, index=False)
    print(f"Predictions saved to {csv_file_path}")

# Load data and prepare model
data = load_data('sales_data.xlsx')
model, X, y = prepare_model(data)
trained_model = train_model(model, X, y)

# User inputs
start_date = input("Enter the start date (YYYY-MM-DD): ")
num_days = int(input("Enter the number of days to predict: "))

# Generate new data and predict
new_data = generate_data_for_days(start_date, num_days)
predictions = make_predictions(trained_model, new_data)

# Display predictions
print("Predicted Revenue ($) for the next {} days from {}: ".format(num_days, start_date))
for i, prediction in enumerate(predictions, 1):
    print(f"Day {i}: ${prediction:.2f}")

# Save predictions to CSV
save_predictions_to_csv(predictions, start_date, num_days)

import pandas as pd
import numpy as np
from datetime import datetime, timedelta
import matplotlib.pyplot as plt
from sklearn.preprocessing import OneHotEncoder
from sklearn.compose import ColumnTransformer
from sklearn.pipeline import Pipeline
from sklearn.linear_model import LinearRegression

# Function to load data
def load_data(file_path):
    data = pd.read_excel(file_path)
    data['Date'] = pd.to_datetime(data['Date'])
    data['Day of Week'] = data['Date'].dt.dayofweek
    data['Month'] = data['Date'].dt.month
    return data.drop(columns=['Date'])

# Function to prepare the model
def prepare_model(data):
    X = data.drop(columns=["Revenue ($)"])
    y = data["Revenue ($)"]

    categorical_columns = X.select_dtypes(include=['object']).columns.tolist()
    categorical_columns += ['Day of Week', 'Month']

    preprocessor = ColumnTransformer(
        transformers=[
            ('cat', OneHotEncoder(handle_unknown='ignore'), categorical_columns)
        ],
        remainder='passthrough'
    )

    model = Pipeline(steps=[
        ('preprocessor', preprocessor),
        ('regressor', LinearRegression())
    ])

    return model, X, y

# Function to train the model
def train_model(model, X, y):
    model.fit(X, y)
    return model

# Function to make predictions
def make_predictions(model, new_data):
    return model.predict(new_data)

# Function to generate data for multiple days
def generate_data_for_days(start_date, num_days):
    base_date = pd.to_datetime(start_date)
    dates = [base_date + timedelta(days=i) for i in range(num_days)]
    days_of_week = [date.dayofweek for date in dates]
    months = [date.month for date in dates]

    new_data = pd.DataFrame({
        'Day of Week': days_of_week,
        'Month': months,
        'Flavor': ['Vanilla'] * num_days,
        'Cup Size': ['Medium'] * num_days,
        'Units Sold': [30] * num_days,
        'Promotions': ['20% off'] * num_days,
        'Seasonality': ['Winter'] * num_days,
        'Distribution Channel': ['Supermarket'] * num_days,
        'Economic Indicators': ['Growing'] * num_days,
        'Competitor Activity': ['Competitor price drop'] * num_days,
        'Inventory Levels': ['Low'] * num_days,
        'Social Media Engagement (%)': [5] * num_days,
        'Ingredient Price Increase (%)': [2] * num_days
    })

    return new_data, dates

# Load data and prepare model
data = load_data('sales_data.xlsx')
model, X, y = prepare_model(data)
trained_model = train_model(model, X, y)

# User inputs
start_date = input("Enter the start date (YYYY-MM-DD): ")
num_days = int(input("Enter the number of days to predict: "))

# Generate new data and predict
new_data, dates = generate_data_for_days(start_date, num_days)
predictions = make_predictions(trained_model, new_data)

# Plotting predictions
plt.figure(figsize=(10, 5))
plt.plot(dates, predictions, marker='o', linestyle='-', color='b')
plt.title('Predicted Sales for the Next {} Days Starting From {}'.format(num_days, start_date))
plt.xlabel('Date')
plt.ylabel('Predicted Revenue ($)')
plt.grid(True)
plt.xticks(rotation=45)
plt.tight_layout()

# Save the figure
plt.savefig('Predicted_Sales.jpg', format='jpg')

# Display the figure
plt.show()

import pandas as pd
from datetime import datetime, timedelta
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import OneHotEncoder
from sklearn.compose import ColumnTransformer
from sklearn.pipeline import Pipeline
from sklearn.linear_model import LinearRegression
from sklearn.metrics import mean_squared_error, r2_score

# Load and prepare data
def load_and_prepare_data(file_path):
    data = pd.read_excel(file_path)
    data['Date'] = pd.to_datetime(data['Date'])
    data['Day of Week'] = data['Date'].dt.dayofweek
    data['Month'] = data['Date'].dt.month
    # Drop the 'Date' column after extracting 'Day of Week' and 'Month'
    data = data.drop(columns=['Date'])
    X = data.drop(columns=["Revenue ($)"])
    y = data["Revenue ($)"]
    return X, y

# Train and evaluate the model
def train_and_evaluate(file_path):
    X, y = load_and_prepare_data(file_path)
    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

    categorical_columns = X.select_dtypes(include=['object']).columns.tolist()
    categorical_columns += ['Day of Week', 'Month']
    preprocessor = ColumnTransformer(
        transformers=[
            ('cat', OneHotEncoder(handle_unknown='ignore'), categorical_columns)
        ],
        remainder='passthrough'
    )

    model = Pipeline(steps=[
        ('preprocessor', preprocessor),
        ('regressor', LinearRegression())
    ])

    model.fit(X_train, y_train)
    y_pred = model.predict(X_test)
    rmse = mean_squared_error(y_test, y_pred, squared=False)
    r2 = r2_score(y_test, y_pred)

    return rmse, r2

# Running the training and evaluation
file_path = 'sales_data.xlsx'  # Ensure this path is correct
rmse, r2 = train_and_evaluate(file_path)
print(f"Root Mean Squared Error (RMSE): {rmse:.2f}")
print(f"R² Score: {r2:.2f}")